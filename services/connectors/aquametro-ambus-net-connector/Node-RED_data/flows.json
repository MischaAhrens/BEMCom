[
    {
        "id": "927c9b3e.6d8038",
        "type": "tab",
        "label": "Main",
        "disabled": false,
        "info": "**Do not edit this flow.**\n\nThis is the main data processing logic for the connectors, the connector template. This flow matches the expected communication pattern of the central API. Hence, again: \n\n**Do not edit this flow.**"
    },
    {
        "id": "68dfd515.661f7c",
        "type": "tab",
        "label": "Specify available_datapoints",
        "disabled": false,
        "info": "This flow should be used to specify available_datapoints. This can be useful to\n* Define available actuators, as these will not be detected automatically by default.\n* Some logic in the flow \"Receive raw_message\" needs to explicitly requiest the data, e.g. by polling some API.\n* If you can simply detect all available datapoints, e.g. by calling some API of the gateway.\n\nDepending on the situation one can simply manually add the data on available datapoints to the \"Manually define additional datapoint\" node, or implement some more advanced logic here that does the sensing automatically.\n\n"
    },
    {
        "id": "219558b7.844058",
        "type": "tab",
        "label": "Receive raw_message",
        "disabled": false,
        "info": "All logic necessary to receive data (sensor datapoints) from the device, gateway or data source.\n\n# Should return\n... the received message as raw message in the format:\n```\nmsg = {\n    \"payload\": {\n        \"raw_message\": <the raw data>\n    }\n}\n```\nE.g.\n```\nmsg = {\n    \"payload\": {\n        \"raw_message\": \"device_1:{sensor_1:2.12,sensor_2:3.12}\"\n    }\n}\n```"
    },
    {
        "id": "545ec5f2.a5913c",
        "type": "tab",
        "label": "Parse raw_message",
        "disabled": false,
        "info": "Parse an object from the received raw sensor datapoint data.\n\n# Receives\n... a message structured like this:\n```\nmsg = {\n    \"payload\": {\n        \"raw_message\": <the raw data>,\n        \"timestamp\": <milliseconds since epoch>\n    }\n}\n```\nE.g.\n```\nmsg = {\n    \"payload\": {\n        \"raw_message\": \"device_1:{sensor_1:2.12,sensor_2:3.12}\",\n        \"timestamp\": 1573680749000\n    }\n}\n```\n\n# Should return\n... a message containing the a parsed version of the raw data, structured like this:\n```\nmsg = {\n    \"payload\": {\n        \"parsed_message\": <the parsed data as object>,\n        \"timestamp\": <milliseconds since epoch>\n    }\n}\n```\nE.g.\n```\nmsg = {\n    \"payload\": {\n        \"parsed_message\": {\n            \"device_1\": {\n                \"sensor_1\": \"2.12\",\n                \"sensor_2\": \"3.12\"\n            }\n        },\n        \"timestamp\": 1573680749000\n    }\n}\n```"
    },
    {
        "id": "9f1169a9.8e23c8",
        "type": "tab",
        "label": "Send command",
        "disabled": false,
        "info": ""
    },
    {
        "id": "72d61467.c7c86c",
        "type": "tab",
        "label": "Flow 1",
        "disabled": false,
        "info": ""
    },
    {
        "id": "2f246a38.edf956",
        "type": "subflow",
        "name": "Log handler",
        "info": "A central log handler that sends all log messages of Node-REDs internal logger via MQTT. The messages are published on the topic defined by the `MQTT_TOPIC_LOGS` environment variable.\nThe log handler uses a TCP socket to connect Node-REDs internal logger with the flow.\n\n# Usage\nDeploy one (and only one) instance of the node in a Node-RED instance. If you deploy more than one node the following error will occur:\n```\n\"unable to listen on port 1337, error: Error: listen EADDRINUSE: address already in use :::1338\"\n```\nYou may have to restart Node-RED (or the container) after inserting the node in the flow.\n\nAll log messages will be caught automatically, this includes the warn and error messages displayed in Node-REDs debug message log but also the internal info messages not shown there. \n\nTo explicitly log in function nodes use the `node` attribute as explained [here](https://nodered.org/docs/user-guide/writing-functions#logging-events), i.e. use: \n\n```\nnode.log(..)\nnode.warn(..)\nnode.error(..)\nnode.debug(..)\nnode.trace(..)\n```\n\n# Log levels\n\n... are converted to python standard, that is:\n\n* 10 (DEBUG) Something happened which is only relevant for developers of the application.\n* 20 (INFO) Something happened.\n* 30 (WARN) Something happened, which is not a problem a the moment but may become one in future. No data is lost.\n* 40 (ERROR) An error occurred, the processing of one or more messages failed. Some data is lost and/or has not reached the end of the flow. Node-RED and the flows still work.\n* 50 (FATAL) A flow or Node-RED crashed and does not operation as intended. You should not expect that FATAL logs are forwarded as the flow may already be halted.\n\n# Preliminaries\n\nIn order to make this flow work one needs to append the following code into `settings.js` in the `logging` section:\n\n```\n        // Custom log handler that forwards log messages via tcp socket.\n        logforwarder: {\n            // Node red logger configuration see https://nodered.org/docs/user-guide/runtime/logging\n            level: 'info',\n            metrics: false,\n            audit: false,\n            handler: function(conf) {\n                var net = require('net')\n                var logPort = 1337\n                var logHost = 'localhost'\n                var message_cache = []\n                var client_connected = false\n                var client_connecting_scheduled = false\n                var client = new net.Socket()\n\n                // Send message to console, similar format as Node-RED does.\n                // These will not be caught by the logforwarder.\n                function console_log(message){\n                    let now = new Date()\n                    // Add something like \"25 Nov\"\n                    let formated = now.toUTCString().slice(5, 11)\n                    // This should add something like \" 14:24:13\"\n                    formated += now.toUTCString().slice(16, -4)\n                    formated += \" - [info] [LogForwarder] \"\n                    formated += message\n                    console.log(formated)\n                }\n\n                // Send all cached messages once the connection is established.\n                client.on('connect', function() {\n                    console_log(\"LogForwarder: Connected\")\n                    client_connected = true\n                    client_connecting_scheduled = false\n                    while(message_cache.length) {\n                        client.write(JSON.stringify(message_cache.shift())+\"\\n\")\n                    }\n                })\n\n                client.on('error', function(err){\n                    if (client_connected === true){\n                        console_log(\n                          \"LogForwarder: Experienced error. Reconnecting.\"\n                        )\n                        console_log(err)\n                        client_connected = false\n                    }\n                    if (client_connecting_scheduled === false){\n                        client_connecting_scheduled = true\n                        // Delay connecting to allow Node-Red to list to\n                        // TCP port first.\n                        setTimeout(function(){\n                            client.connect(logPort, logHost)\n                        }, 2500)\n                    }\n                })\n\n                // Return the function that will do the actual logging to the\n                // logging system.\n                return function(msg) {\n                    // Store message so it won't get lost on error\n                    message_cache.push(msg)\n                    if (client_connected === true) {\n                            client.write(JSON.stringify(msg)+\"\\n\")\n                            // Remove message if send successfully.\n                    } else {\n\n                        if (client_connecting_scheduled === false){\n                            client_connecting_scheduled = true\n                            // Delay connecting to allow Node-Red to list to\n                            // TCP port first.\n                            setTimeout(function(){\n                                client.connect(logPort, logHost)\n                            }, 2500)\n                        }\n                    }\n                }\n            }\n        }\n```",
        "category": "",
        "in": [],
        "out": [],
        "env": [],
        "color": "#7bb27f",
        "icon": "node-red/envelope.svg",
        "status": {
            "x": 800,
            "y": 280,
            "wires": [
                {
                    "id": "d09fe5cf.357788",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "4b055c82.2ce1b4",
        "type": "subflow",
        "name": "Heartbeat",
        "info": "This node sends a periodic heartbeat every `heartbeat_period` seconds via MQTT to the topic defined in the environment variable `MQTT_TOPIC_HEARTBEAT`. \n\nThe `heartbeat_period` defaults to 5 seconds and can be changed as subflow property. \n\nThe heartbeat message object looks e.g. like this:\n\n```\n\"payload\": {\n\t\"this_heartbeats_timestamp\": 1571927361261,\n \t\"next_heartbeats_timestamp\": 1571927366261\n}\n```",
        "category": "",
        "in": [],
        "out": [],
        "env": [
            {
                "name": "heartbeat_period",
                "type": "num",
                "value": "5",
                "ui": {
                    "type": "input",
                    "opts": {
                        "types": [
                            "num"
                        ]
                    },
                    "label": {}
                }
            }
        ],
        "color": "#FF0000",
        "icon": "node-red/status.svg",
        "status": {
            "x": 400,
            "y": 200,
            "wires": [
                {
                    "id": "60fdc941.ed1208",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "a96a98ee.ee4868",
        "type": "subflow",
        "name": "datapoint_map receiver",
        "info": "This subflow will listen to the MQTT topic defined in the environment variable `MQTT_TOPIC_DATAPOINT_MAP` for datapoint mappings, that is the information which datapoint should be read/written from/to which MQTT topic. The datapoint mappings are stored in the global variable `datapoint_map`.\n\nThe expected and stored datapoint map is formated as follows:\n```\n\"sensor\": {\n\t\"Channel__P__value__0\": \"example-connector/msgs/0001\",\n    \"Channel__P__unit__0\": \"example-connector/msgs/0002\",\n},\n\"actuator\": {\n\t\"example-connector/msgs/0003\": \"Channel__P__setpoint__0\",\n}\n```",
        "category": "",
        "in": [],
        "out": [],
        "env": [],
        "color": "#D8BFD8",
        "icon": "node-red/arrow-in.svg",
        "status": {
            "x": 260,
            "y": 240,
            "wires": [
                {
                    "id": "89c51b97.13a598",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "3674b7d8.02a168",
        "type": "subflow",
        "name": "Update available_datapoints",
        "info": "# General\nThis subflow can be used to manage which datapoints are available and send respective messages to the admin panel. It is not necessary to define all available datapoints at a time, instead it is ok to send in information on one/many available datatpoints in seperate messages. The later is useful to automatically generate the list of available datapoints while listening to incoming sensor messages. \n\nThe subflow will maintain a backup of the latest list of available messages in `available_messages.json`. This prevents sending false alarms to the admin panel that datapoints are no longer available after restarting the flow. If you have removed datapoints you should delete the file to forward the information.\n\n# Receives\n... a message formated like: \n```\nmsg = {\n    \"payload\": {\n    \t\"sensor\": {\n    \t\t<internal id of sensor 1>: <example value of sensor 1>,\n            <internal id of sensor 2>: <example value of sensor 2>,\n            ...\n    \t},\n    \t\"actuator\": {\n    \t\t<internal id of actuator 1>: <example value of actuator 1>,\n    \t\t<internal id of actuator 2>: <example value of actuator 2>,\n    \t\t...\n    \t}\n    }\n}\n```\nE.g. \n```\nmsg = {\n    \"payload\": {\n    \t\"sensor\": {\n    \t\t\"Channel__P__value__0\": 0.122,\n            \"Channel__P__unit__0\": \"kW\",\n    \t},\n    \t\"actuator\": {\n    \t\t\"Channel__P__setpoint__0\": 0.4,\n    \t}\n    }\n}\n```",
        "category": "",
        "in": [
            {
                "x": 60,
                "y": 280,
                "wires": [
                    {
                        "id": "c3f25d9b.9f1f7"
                    }
                ]
            }
        ],
        "out": [],
        "env": [],
        "color": "#3FADB5",
        "icon": "node-red/bridge.svg"
    },
    {
        "id": "879bee.da78c41",
        "type": "mqtt-broker",
        "z": "2f246a38.edf956",
        "name": "environment variable broker",
        "broker": "$(MQTT_BROKER_HOST)",
        "port": "$(MQTT_BROKER_PORT)",
        "clientid": "",
        "usetls": false,
        "compatmode": false,
        "keepalive": "60",
        "cleansession": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthPayload": "",
        "closeTopic": "",
        "closeQos": "0",
        "closePayload": "",
        "willTopic": "",
        "willQos": "0",
        "willPayload": ""
    },
    {
        "id": "f0d21eb0.93967",
        "type": "mqtt-broker",
        "z": "",
        "name": "environment variable broker",
        "broker": "$(MQTT_BROKER_HOST)",
        "port": "$(MQTT_BROKER_PORT)",
        "clientid": "",
        "usetls": false,
        "compatmode": false,
        "keepalive": "60",
        "cleansession": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthPayload": "",
        "closeTopic": "",
        "closeQos": "0",
        "closePayload": "",
        "willTopic": "",
        "willQos": "0",
        "willPayload": ""
    },
    {
        "id": "1980e6e1.5dc979",
        "type": "change",
        "z": "927c9b3e.6d8038",
        "name": "Add receival timestamp",
        "rules": [
            {
                "t": "set",
                "p": "payload.timestamp",
                "pt": "msg",
                "to": "",
                "tot": "date"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 430,
        "y": 220,
        "wires": [
            [
                "7e5140d4.21391",
                "5d6ccddc.75fcd4"
            ]
        ],
        "info": "Append the timestamp.\n# Returns\n```\nmsg = {\n    \"payload\": {\n        \"raw_message\": <the raw data>,\n        \"timestamp\": <milliseconds since epoch>\n    }\n}\n```\nE.g.\n```\nmsg = {\n    \"payload\": {\n        \"raw_message\": \"device_1:{sensor_1:2.12,sensor_2:3.12}\",\n        \"timestamp\": 1573680749000\n    }\n}\n```"
    },
    {
        "id": "ac872115.7ebd2",
        "type": "tcp in",
        "z": "2f246a38.edf956",
        "name": "",
        "server": "server",
        "host": "",
        "port": "1337",
        "datamode": "stream",
        "datatype": "utf8",
        "newline": "\\n",
        "topic": "",
        "base64": false,
        "x": 100,
        "y": 80,
        "wires": [
            [
                "7cba1842.0813a8"
            ]
        ]
    },
    {
        "id": "d4772456.48c0d8",
        "type": "comment",
        "z": "2f246a38.edf956",
        "name": "Display the combined status of the tcp connection with the Node-RED logger and mqtt connection as subflow status.",
        "info": "",
        "x": 430,
        "y": 240,
        "wires": []
    },
    {
        "id": "a7489345.cc4ee",
        "type": "function",
        "z": "2f246a38.edf956",
        "name": "Format log msg",
        "func": "/*\nThe incomming object looks like:\n\ntopic: \"\"\npayload: \n    level: 40\n    id: \"21b82c2e.44d1e4\"\n    type: \"function\"\n    msg: \"TEest 112233\"\n    _alias: \"cd54c61d.3064d8\"\n    z: \"81cb38e5.a724b8\"\n    timestamp: 1571843907448\nip: \"::ffff:127.0.0.1\"\nport: 54404\n_session:\n    type: \"tcp\"\n    id: \"b4c68458.f1e368\"\n_msgid: \"ef84fdce.533b1\"\n\nThe outgoing msg should look like:\npayload: \n    timestamp: 1571843907448\n    msg: \"TEest 112233\"\n    emitter: \"cd54c61d.3064d8\"\n    level: 20\n*/ \n\n// The node id of the emitting node is stored in _alias if the node is within a\n// subflow. Else it's the id field\nlet emitter\nif ('_alias' in msg.payload) {\n    emitter = msg.payload._alias\n} else {\n    emitter = msg.payload.id\n}\n\n// Parse the log levels to Python convention\nlet level\nswitch (msg.payload.level) {\n    case 10:\n        level = 50\n        break\n    case 20:\n        level = 40\n        break\n    case 30:\n        level = 30\n        break\n    case 40:\n        level = 20\n        break\n    case 50:\n        level = 10\n        break\n    default:\n        level = null\n}\n\npayload = {\n    \"timestamp\": msg.payload.timestamp,\n    \"msg\": msg.payload.msg,\n    \"emitter\": emitter,\n    \"level\": level\n}\n\nreturn {\"payload\": payload}",
        "outputs": 1,
        "noerr": 0,
        "x": 560,
        "y": 80,
        "wires": [
            [
                "f18f0326.62d8b"
            ]
        ]
    },
    {
        "id": "7cba1842.0813a8",
        "type": "json",
        "z": "2f246a38.edf956",
        "name": "String to JSON objecet",
        "property": "payload",
        "action": "obj",
        "pretty": false,
        "x": 320,
        "y": 80,
        "wires": [
            [
                "a7489345.cc4ee"
            ]
        ]
    },
    {
        "id": "8c4b1179.2783d",
        "type": "comment",
        "z": "2f246a38.edf956",
        "name": "The pipe line for the log msgs. Append other endpoints as required.",
        "info": "",
        "x": 280,
        "y": 40,
        "wires": []
    },
    {
        "id": "f18f0326.62d8b",
        "type": "mqtt out",
        "z": "2f246a38.edf956",
        "name": "",
        "topic": "$(MQTT_TOPIC_LOGS)",
        "qos": "2",
        "retain": "false",
        "broker": "879bee.da78c41",
        "x": 830,
        "y": 80,
        "wires": []
    },
    {
        "id": "269a9da2.6ce062",
        "type": "status",
        "z": "2f246a38.edf956",
        "name": "",
        "scope": [
            "ac872115.7ebd2",
            "f18f0326.62d8b"
        ],
        "x": 100,
        "y": 280,
        "wires": [
            [
                "d09fe5cf.357788"
            ]
        ]
    },
    {
        "id": "d09fe5cf.357788",
        "type": "function",
        "z": "2f246a38.edf956",
        "name": "Compute subflow status",
        "func": "/* This node will receive status messages from \"tcp in\" node and \"mqtt out\".\n\nThe \"tcp in\" status looks like this:\nstatus:\n    text: \"1 connection\"\n    event: \"connect\"\n    ip: \"::ffff:127.0.0.1\"\n    port: 57886\n_session:\n    type: \"tcp\"\n    id: \"4a30194f.2d0008\"\nsource:\n    id: \"51c67f81.6eaad\"\n    type: \"tcp in\"\n_msgid: \"bb2b70c5.abf9f\"\n\nThe \"mqtt out\" status like this:\nstatus:\n    fill: \"yellow\"\n    shape: \"ring\"\n    text: \"node-red:common.status.connecting\"\nsource:\n    id: \"9a6c9ede.e185c\"\n    type: \"mqtt out\"\n_msgid: \"45a3aa0f.960234\"\n\nThe following code will compute the following status:\n* green (connected): if both ends are connected.\n* yellow ring (connecting): if any of both ends are still connecting.\n* grey ring (unknown): for undefined states, especially if more than\n  one endpoint is connected to \"tcp in\"\n* red (disconnected): If one of both nodes is not connected.\n*/\n\n// Store the last status for each of the two nodes, as only one is received\n// at a time but both are required to compute the status.\nif (msg.status.source.type === \"mqtt out\") {\n    context.set('mqtt_status_text', msg.status.text)\n}\nif (msg.status.source.type === \"tcp in\") {\n    context.set('tcp_status_text', msg.status.text)\n}\n\n// Compute the status assume disconnected as default value.\nlet status\nlet mqtt_status_text = context.get(\"mqtt_status_text\") || \"node-red:common.status.disconnected\"\nlet tcp_status_text = context.get(\"tcp_status_text\") || \"0 connection\"\n\nif (mqtt_status_text === \"node-red:common.status.connected\" && \n        tcp_status_text === \"1 connection\") {\n    status = {\n        \"fill\": \"green\",\n        \"shape\": \"dot\",\n        \"text\": \"node-red:common.status.connected\"\n    }\n    return {\"status\": status}\n}\n\nif (mqtt_status_text === \"node-red:common.status.disconnected\" || \n        tcp_status_text === \"0 connection\") {\n    status = {\n        \"fill\": \"red\",\n        \"shape\": \"ring\",\n        \"text\": \"node-red:common.status.disconnected\",\n        \"tcp status\": tcp_status_text\n    }\n    return {\"status\": status}\n}\n\n// TCP in has no connecting phase. Hence only connecting status\n// if already connected to tcp in.\nif (mqtt_status_text === \"node-red:common.status.connecting\" && \n        tcp_status_text === \"1 connection\") {\n    status = {\n        \"fill\": \"yellow\",\n        \"shape\": \"ring\",\n        \"text\": \"node-red:common.status.connecting\"\n    }\n    return {\"status\": status}\n}\n\n// For every other state, which should \nstatus = {\n    \"fill\": \"grey\",\n    \"shape\": \"ring\",\n    \"text\": \"unknown\"\n}\n\nreturn {\"status\": status}",
        "outputs": 1,
        "noerr": 0,
        "x": 470,
        "y": 280,
        "wires": [
            []
        ]
    },
    {
        "id": "f3d7689a.7f5be8",
        "type": "inject",
        "z": "4b055c82.2ce1b4",
        "name": "",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "repeat": "$(heartbeat_period)",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "x": 130,
        "y": 80,
        "wires": [
            [
                "66e8a12a.91483"
            ]
        ]
    },
    {
        "id": "1c3a8d6.3407573",
        "type": "mqtt out",
        "z": "4b055c82.2ce1b4",
        "name": "",
        "topic": "$(MQTT_TOPIC_HEARTBEAT)",
        "qos": "",
        "retain": "",
        "broker": "f0d21eb0.93967",
        "x": 750,
        "y": 80,
        "wires": []
    },
    {
        "id": "66e8a12a.91483",
        "type": "function",
        "z": "4b055c82.2ce1b4",
        "name": "Format heartbeat msg",
        "func": "let heartbeat_period = env.get(\"heartbeat_period\")\n\n//timestamps as usual in milliseconds, hearbeat period in seconds\npayload = {\n    \"this_heartbeats_timestamp\": msg.payload,\n    \"next_heartbeats_timestamp\": msg.payload + heartbeat_period * 1000\n}\nreturn {\"payload\": payload}",
        "outputs": 1,
        "noerr": 0,
        "x": 420,
        "y": 80,
        "wires": [
            [
                "1c3a8d6.3407573"
            ]
        ]
    },
    {
        "id": "a6b20f83.8bb9d",
        "type": "comment",
        "z": "4b055c82.2ce1b4",
        "name": "Periodically send the heartbeat messages.",
        "info": "",
        "x": 200,
        "y": 40,
        "wires": []
    },
    {
        "id": "60fdc941.ed1208",
        "type": "status",
        "z": "4b055c82.2ce1b4",
        "name": "",
        "scope": [
            "1c3a8d6.3407573"
        ],
        "x": 100,
        "y": 200,
        "wires": [
            []
        ]
    },
    {
        "id": "b58bf767.ab87a8",
        "type": "comment",
        "z": "4b055c82.2ce1b4",
        "name": "Display MQTT connection status as subflow status",
        "info": "",
        "x": 230,
        "y": 160,
        "wires": []
    },
    {
        "id": "2e5b1c4.20be3e4",
        "type": "subflow:4b055c82.2ce1b4",
        "z": "927c9b3e.6d8038",
        "name": "",
        "env": [],
        "x": 260,
        "y": 40,
        "wires": []
    },
    {
        "id": "d9bfa648.e879e8",
        "type": "subflow:a96a98ee.ee4868",
        "z": "927c9b3e.6d8038",
        "name": "",
        "env": [],
        "x": 460,
        "y": 40,
        "wires": []
    },
    {
        "id": "b7064af6.613328",
        "type": "mqtt out",
        "z": "927c9b3e.6d8038",
        "name": "",
        "topic": "$(MQTT_TOPIC_RAW_MESSAGE_TO_DB)",
        "qos": "2",
        "retain": "false",
        "broker": "f0d21eb0.93967",
        "x": 1170,
        "y": 220,
        "wires": [],
        "info": "Send raw_message content to raw_message DB."
    },
    {
        "id": "7e5140d4.21391",
        "type": "switch",
        "z": "927c9b3e.6d8038",
        "name": "if ${SEND_RAW_MESSAGE_TO_DB} == TRUE",
        "property": "SEND_RAW_MESSAGE_TO_DB",
        "propertyType": "env",
        "rules": [
            {
                "t": "eq",
                "v": "TRUE",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 780,
        "y": 220,
        "wires": [
            [
                "b7064af6.613328"
            ]
        ]
    },
    {
        "id": "2ee2fa20.944a36",
        "type": "mqtt in",
        "z": "927c9b3e.6d8038",
        "name": "",
        "topic": "$(MQTT_TOPIC_RAW_MESSAGE_REPROCESS)",
        "qos": "1",
        "datatype": "json",
        "broker": "f0d21eb0.93967",
        "x": 210,
        "y": 280,
        "wires": [
            [
                "5d6ccddc.75fcd4"
            ]
        ],
        "info": "Yields old messages stored in the raw_message DB scheduled for reprocessing."
    },
    {
        "id": "4167d4ab.a3237c",
        "type": "function",
        "z": "927c9b3e.6d8038",
        "name": "Flatten object",
        "func": "// from https://stackoverflow.com/questions/44134212/best-way-to-flatten-js-object-keys-and-values-to-a-single-depth-array\nfunction flattenObject(ob) {\n    var toReturn = {};\n\n    for (var i in ob) {\n        if (!ob.hasOwnProperty(i)) continue;\n\n        if ((typeof ob[i]) == 'object' && ob[i] !== null) {\n            var flatObject = flattenObject(ob[i]);\n            for (var x in flatObject) {\n                if (!flatObject.hasOwnProperty(x)) continue;\n\n                toReturn[i + '__' + x] = flatObject[x];\n            }\n        } else {\n            toReturn[i] = ob[i];\n        }\n    }\n    return toReturn;\n}\n\nlet parsed_message = msg.payload.parsed_message\nlet flattened_message = flattenObject(parsed_message)\ndelete msg.payload.parsed_message\nmsg.payload[\"flattened_message\"] = flattened_message\n\nreturn msg",
        "outputs": 1,
        "noerr": 0,
        "x": 140,
        "y": 340,
        "wires": [
            [
                "961689eb.6df078",
                "5a8f8f58.d3c16",
                "284cd3db.1f53dc"
            ]
        ],
        "info": "Flattens the incomming object to depth 1, i.e that every leaf of the incomming object can be accessed with a unique key directly from flat_message object.\n# Returns\nShould return the a message with the flattend data like:\n```\nmsg = {\n    \"payload\": {\n        \"flattened_message\": <the parsed data as flattend object>,\n        \"timestamp\": <milliseconds since epoch>\n    }\n}\n```\nE.g.\n```\nmsg = {\n    \"payload\": {\n        \"flattened_message\": {\n            \"device_1__sensor_1\": \"2.12\"\n            \"device_1__sensor_2\": \"3.12\"\n        },\n        \"timestamp\": 1573680749000\n    }\n}\n```"
    },
    {
        "id": "2deac0e3.ad371",
        "type": "mqtt in",
        "z": "a96a98ee.ee4868",
        "name": "",
        "topic": "$(MQTT_TOPIC_DATAPOINT_MAP)",
        "qos": "1",
        "datatype": "json",
        "broker": "f0d21eb0.93967",
        "x": 190,
        "y": 80,
        "wires": [
            [
                "bc388144.0d621"
            ]
        ]
    },
    {
        "id": "6aae28b2.fb2688",
        "type": "link out",
        "z": "219558b7.844058",
        "name": "flow \"Receive raw_message\" out",
        "links": [
            "b6c60262.69fb9"
        ],
        "x": 1135,
        "y": 620,
        "wires": []
    },
    {
        "id": "b6c60262.69fb9",
        "type": "link in",
        "z": "927c9b3e.6d8038",
        "name": "flow \"Main\" in (after \"Receive raw_message\")",
        "links": [
            "6aae28b2.fb2688",
            "b1799f87.c832f"
        ],
        "x": 275,
        "y": 220,
        "wires": [
            [
                "1980e6e1.5dc979"
            ]
        ]
    },
    {
        "id": "2a627646.87bc4a",
        "type": "comment",
        "z": "927c9b3e.6d8038",
        "name": "Processing of sensor datapoint messages",
        "info": "",
        "x": 180,
        "y": 180,
        "wires": []
    },
    {
        "id": "5d6ccddc.75fcd4",
        "type": "link out",
        "z": "927c9b3e.6d8038",
        "name": "flow \"Main\" out (before \"Parse raw_message\")",
        "links": [
            "6a1342ab.73305c"
        ],
        "x": 615,
        "y": 280,
        "wires": []
    },
    {
        "id": "6a1342ab.73305c",
        "type": "link in",
        "z": "545ec5f2.a5913c",
        "name": "flow \"Parse raw_message\" in",
        "links": [
            "5d6ccddc.75fcd4"
        ],
        "x": 155,
        "y": 40,
        "wires": [
            [
                "1af4cf17.b34d41"
            ]
        ]
    },
    {
        "id": "376a4260.2d545e",
        "type": "link out",
        "z": "545ec5f2.a5913c",
        "name": "flow \"Parse raw_message\" out",
        "links": [
            "498bc454.265e5c"
        ],
        "x": 915,
        "y": 120,
        "wires": []
    },
    {
        "id": "498bc454.265e5c",
        "type": "link in",
        "z": "927c9b3e.6d8038",
        "name": "flow \"Main\" in (after \"Parse raw_message\")",
        "links": [
            "376a4260.2d545e"
        ],
        "x": 855,
        "y": 280,
        "wires": [
            [
                "4167d4ab.a3237c"
            ]
        ]
    },
    {
        "id": "3f718945.ab8206",
        "type": "comment",
        "z": "927c9b3e.6d8038",
        "name": "Flow: Parse raw_message",
        "info": "Parse an object from the raw data.\n\n# Receives\n... a message structured like this:\n```\nmsg = {\n    \"payload\": {\n        \"raw_message\": <the raw data>,\n        \"timestamp\": <milliseconds since epoch>\n    }\n}\n```\nE.g.\n```\nmsg = {\n    \"payload\": {\n        \"raw_message\": \"device_1:{sensor_1:2.12,sensor_2:3.12}\",\n        \"timestamp\": 1573680749000\n    }\n}\n```\n\n# Should return\n... a message containing the a parsed version of the raw data, structured like this:\n```\nmsg = {\n    \"payload\": {\n        \"parsed_message\": <the parsed data as object>,\n        \"timestamp\": <milliseconds since epoch>\n    }\n}\n```\nE.g.\n```\nmsg = {\n    \"payload\": {\n        \"parsed_message\": {\n            \"device_1\": {\n                \"sensor_1\": \"2.12\",\n                \"sensor_2\": \"3.12\"\n            }\n        },\n        \"timestamp\": 1573680749000\n    }\n}\n```",
        "x": 730,
        "y": 280,
        "wires": []
    },
    {
        "id": "113065f1.cbdada",
        "type": "comment",
        "z": "927c9b3e.6d8038",
        "name": "Flow: Receive raw_message",
        "info": "All logic necessary to receive data from device, gateway or data source.\n\n# Should return\n... the received message as raw message in the format:\n```\nmsg = {\n    \"payload\": {\n        \"raw_message\": <the raw data>\n    }\n}\n```\nE.g.\n```\nmsg = {\n    \"payload\": {\n        \"raw_message\": \"device_1:{sensor_1:2.12,sensor_2:3.12}\"\n    }\n}\n```",
        "x": 140,
        "y": 220,
        "wires": []
    },
    {
        "id": "961689eb.6df078",
        "type": "change",
        "z": "927c9b3e.6d8038",
        "name": "convert format to update available_datapoints with the currently processed sensor datapoints",
        "rules": [
            {
                "t": "move",
                "p": "payload.flattened_message",
                "pt": "msg",
                "to": "payload.sensor",
                "tot": "msg"
            },
            {
                "t": "delete",
                "p": "payload.timestamp",
                "pt": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 640,
        "y": 340,
        "wires": [
            [
                "a5ae1e6e.e530a"
            ]
        ]
    },
    {
        "id": "a5ae1e6e.e530a",
        "type": "subflow:3674b7d8.02a168",
        "z": "927c9b3e.6d8038",
        "name": "",
        "env": [],
        "x": 1220,
        "y": 340,
        "wires": []
    },
    {
        "id": "e740f12a.0dc05",
        "type": "function",
        "z": "3674b7d8.02a168",
        "name": "Check if new datapoints have been found and update global.available_datapoints if so.",
        "func": "/*\nThe structure of the incomming msg and the available datapoints object \nshould be generally like:\n\"payload\": {\n\t\"sensor\": {\n\t\t\"Channel__P__value__0\": 0.122,\n        \"Channel__P__unit__0\": \"kW\",\n\t},\n\t\"actuator\": {\n\t\t\"Channel__P__setpoint__0\": 0.4,\n\t}\n}\n*/\n\n// Check for each sensor/actuator datapoint if it is already known to \n// available_datapoints. Trigger sending an update if so. Update the values of \n// the datapoints every time so next time we send available_datapoints it will\n// carry examples of the most recent values.\nlet new_datapoints = false\nlet available_datapoints = global.get(\"available_datapoints\")\nlet available_datapoints_update = msg.payload\n\nfor (let datapoint_type of [\"sensor\", \"actuator\"]) {\n\n    // Default to empty dict in case no datapoints of this type are known yet.\n    let ad_per_type = available_datapoints[datapoint_type] || {}\n    let ad_update_per_type = available_datapoints_update[datapoint_type] || {}\n\n    for (let datapoint_id_update in ad_update_per_type) {\n        \n        if ( ! (datapoint_id_update in ad_per_type) ) {\n            new_datapoints = true\n        }\n        \n        // Store the latest datapoint value.\n        ad_per_type[datapoint_id_update] = ad_update_per_type[datapoint_id_update]\n        \n    }\n    \n    // Store the type related sub_object back to the main object.\n    available_datapoints[datapoint_type] = ad_per_type\n}\n\n// Store and return the updated available_datapoints.\nglobal.set(\"available_datapoints\", available_datapoints)\n\nmsg = {\n    \"payload\": available_datapoints, \n    \"new_datapoints\": new_datapoints\n}\n\nreturn msg",
        "outputs": 1,
        "noerr": 0,
        "x": 980,
        "y": 280,
        "wires": [
            [
                "2fe7b0c4.bfb28"
            ]
        ]
    },
    {
        "id": "2fe7b0c4.bfb28",
        "type": "switch",
        "z": "3674b7d8.02a168",
        "name": "If new datapoints have been found",
        "property": "new_datapoints",
        "propertyType": "msg",
        "rules": [
            {
                "t": "true"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 220,
        "y": 420,
        "wires": [
            [
                "b53eeea3.4c627",
                "c7d69be6.186988"
            ]
        ]
    },
    {
        "id": "b53eeea3.4c627",
        "type": "mqtt out",
        "z": "3674b7d8.02a168",
        "name": "",
        "topic": "$(MQTT_TOPIC_AVAILABLE_DATAPOINTS)",
        "qos": "2",
        "retain": "true",
        "broker": "f0d21eb0.93967",
        "x": 1110,
        "y": 420,
        "wires": []
    },
    {
        "id": "b667759e.2c1018",
        "type": "change",
        "z": "a96a98ee.ee4868",
        "name": "Store to global.datapoint_map",
        "rules": [
            {
                "t": "set",
                "p": "datapoint_map",
                "pt": "global",
                "to": "payload",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 870,
        "y": 80,
        "wires": [
            []
        ]
    },
    {
        "id": "89c51b97.13a598",
        "type": "status",
        "z": "a96a98ee.ee4868",
        "name": "",
        "scope": [
            "2deac0e3.ad371"
        ],
        "x": 100,
        "y": 240,
        "wires": [
            []
        ]
    },
    {
        "id": "5a8f8f58.d3c16",
        "type": "function",
        "z": "927c9b3e.6d8038",
        "name": "Filter datapoints and build sensor messages",
        "func": "// Use an empty datapoint map if none has been received via MQTT yet to prevent\n// the script from throwing errors.\nlet datapoint_map = global.get(\"datapoint_map\") || {\"sensor\": {}, \"actuator\": {}}\nlet sensor_map = datapoint_map[\"sensor\"]\n\nlet datapoint_msgs = []\nlet sensor_data_flat = msg.payload.flattened_message\n\n// We could also iterate over all entries of sensor map, but this should be more\n// efficient if we expect many messages with only some datapoints, as e.g. is\n// the case for homematic.\nfor (let internal_sensor_id in sensor_data_flat){\n    // Only process messages of datapoints which have been selected for sending\n    // via MQTT in the central admin UI.\n    if (internal_sensor_id in sensor_map){\n        let datapoint_msg = {\n            \"payload\": {\n                \"value\": sensor_data_flat[internal_sensor_id],\n                \"timestamp\": msg.payload.timestamp,\n            },\n            \"topic\": sensor_map[internal_sensor_id],\n        }\n        datapoint_msgs.push(datapoint_msg)\n    }\n    \n}\n\nreturn [datapoint_msgs]",
        "outputs": 1,
        "noerr": 0,
        "x": 490,
        "y": 400,
        "wires": [
            [
                "517add71.6239e4"
            ]
        ],
        "info": "This function block will create one message for every entry in the input msg that has been selected for sending to the message broker, that is an entry for which a datapoint_map entry exists.\n\n# Given \n... that a datapoint_map is stored in global context with content:\n```\n{\n    \"sensor\": {\n        \"device_1__sensor_1\": \"example-connector/msgs/0001\",\n        \"device_1__sensor_2\": \"example-connector/msgs/0002\"\n    },\n    \"actuator\": {\n        \"example-connector/msgs/0003\": \"device_1__actuator_1\"\n    }\n}\n```\n\n# Receives\nAnd this block would receive the following input: \n```\nmsg = {\n    \"payload\": {\n        \"flattened_message\": {\n            \"device_1__sensor_1\": \"2.12\",\n            \"device_1__sensor_2\": \"3.12\",\n            \"device_2__sensor_2\": \"88822\"\n        },\n        \"timestamp\": 1573680749000\n    }\n}\n```\n\n# Returns\nThe node would return the following two messages:\n```\nmsg = {\n    \"payload\": {\n        \"value\": \"2.12\",\n        \"timestamp\": 1573680749000,\n    },\n    \"topic\": \"example-connector/msgs/0001\",\n}\n\nmsg = {\n    \"payload\": {\n        \"value\": \"3.12\",\n        \"timestamp\": 1573680749000,\n    },\n    \"topic\": \"example-connector/msgs/0002\",\n}\n\n```\n"
    },
    {
        "id": "517add71.6239e4",
        "type": "mqtt out",
        "z": "927c9b3e.6d8038",
        "name": "MQTT datapoint message topics",
        "topic": "",
        "qos": "1",
        "retain": "true",
        "broker": "f0d21eb0.93967",
        "x": 1210,
        "y": 400,
        "wires": []
    },
    {
        "id": "9d68458f.255748",
        "type": "comment",
        "z": "927c9b3e.6d8038",
        "name": "Processing of actuator datapoint messages",
        "info": "",
        "x": 180,
        "y": 540,
        "wires": []
    },
    {
        "id": "f5ba72cb.d2e31",
        "type": "mqtt in",
        "z": "927c9b3e.6d8038",
        "name": "",
        "topic": "$(MQTT_TOPIC_DATAPOINT_MESSAGE_WILDCARD)",
        "qos": "1",
        "datatype": "json",
        "broker": "f0d21eb0.93967",
        "x": 230,
        "y": 580,
        "wires": [
            [
                "14995022.9f798"
            ]
        ]
    },
    {
        "id": "14995022.9f798",
        "type": "function",
        "z": "927c9b3e.6d8038",
        "name": "Filter for actuator messages",
        "func": "let datapoint_map = global.get(\"datapoint_map\")\nlet actuator_map = datapoint_map[\"actuator\"]\n\nif (msg.topic in actuator_map){\n    return msg\n}",
        "outputs": 1,
        "noerr": 0,
        "x": 760,
        "y": 580,
        "wires": [
            [
                "3ed4277f.ed75d8"
            ]
        ],
        "info": "This notes lets only these messages through that are actuator messages for this particular connector. This filtering is necessary as there is no way (known to the author) of using dynmic topic lists for receiving MQTT messages in Node-RED.\n\n# Given \n... that a datapoint_map is stored in global context with content:\n```\n{\n    \"sensor\": {\n        \"device_1__sensor_1\": \"example-connector/msgs/0001\",\n        \"device_1__sensor_2\": \"example-connector/msgs/0002\"\n    },\n    \"actuator\": {\n        \"example-connector/msgs/0003\": \"device_1__actuator_1\"\n    }\n}\n```\n\n# Returns\nThis node would only let messages pass through that have been received on topic `example-connector/msgs/0003`."
    },
    {
        "id": "5e4aacbf.6c95d4",
        "type": "subflow:3674b7d8.02a168",
        "z": "68dfd515.661f7c",
        "name": "",
        "env": [],
        "x": 520,
        "y": 40,
        "wires": []
    },
    {
        "id": "b01f4077.79689",
        "type": "inject",
        "z": "68dfd515.661f7c",
        "name": "Manuelly define additional datapoints",
        "topic": "",
        "payload": "{\"sensor\":{},\"actuator\":{}}",
        "payloadType": "json",
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "x": 180,
        "y": 40,
        "wires": [
            [
                "5e4aacbf.6c95d4"
            ]
        ],
        "info": "This node allows you to manually define which datapoints are available (additonally to the automatically found sensor datapoints).\n# Should return\n... a message formated to match the expected input of Update available_datapoints. E.g.\n```\nmsg = {\n    \"payload\": {\n    \t\"sensor\": {\n    \t\t\"Channel__P__value__0\": 0.122,\n            \"Channel__P__unit__0\": \"kW\",\n    \t},\n    \t\"actuator\": {\n    \t\t\"Channel__P__setpoint__0\": 0.4,\n    \t}\n    }\n}\n```"
    },
    {
        "id": "3ed4277f.ed75d8",
        "type": "link out",
        "z": "927c9b3e.6d8038",
        "name": "flow \"Main\" out (before \"Send command\")",
        "links": [
            "3b3d9738.5b6e88"
        ],
        "x": 1135,
        "y": 580,
        "wires": []
    },
    {
        "id": "5f0c81ba.d6873",
        "type": "comment",
        "z": "927c9b3e.6d8038",
        "name": "Flow: Send command",
        "info": "Send a value to the corresponding actuator. \n\n# Receives\n... a message structured like this:\n```\nmsg = {\n    \"payload\": {\n        \"raw_message\": <the raw data>,\n        \"timestamp\": <milliseconds since epoch>\n    }\n}\n```\nE.g.\n```\nmsg = {\n    \"payload\": {\n        \"raw_message\": \"device_1:{sensor_1:2.12,sensor_2:3.12}\",\n        \"timestamp\": 1573680749000\n    }\n}\n```\n\n# Should return\n.. generally nothing. If you want to return status messages about the last/or accepted value of the actuator you might want to inject a respecitve message directly after the \"Parse raw_message\" flow. Consider the expected message format.",
        "x": 1240,
        "y": 580,
        "wires": []
    },
    {
        "id": "3ce1950f.35b4ca",
        "type": "comment",
        "z": "a96a98ee.ee4868",
        "name": "Display the status MQTT connection as subflow status.",
        "info": "",
        "x": 240,
        "y": 200,
        "wires": []
    },
    {
        "id": "f1221d92.14291",
        "type": "comment",
        "z": "a96a98ee.ee4868",
        "name": "Receive and store the datapoint mapping",
        "info": "",
        "x": 200,
        "y": 40,
        "wires": []
    },
    {
        "id": "3b3d9738.5b6e88",
        "type": "link in",
        "z": "9f1169a9.8e23c8",
        "name": "flow \"Send command\" in",
        "links": [
            "3ed4277f.ed75d8"
        ],
        "x": 155,
        "y": 40,
        "wires": [
            [
                "1c26ecc6.986e53"
            ]
        ]
    },
    {
        "id": "f87c8d8f.12b57",
        "type": "delay",
        "z": "3674b7d8.02a168",
        "name": "",
        "pauseType": "delay",
        "timeout": "1",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "x": 360,
        "y": 340,
        "wires": [
            [
                "c3f25d9b.9f1f7"
            ]
        ]
    },
    {
        "id": "c3f25d9b.9f1f7",
        "type": "switch",
        "z": "3674b7d8.02a168",
        "name": "Delay message until available datapoints is loaded from disk.",
        "property": "available_datapoints_loaded",
        "propertyType": "global",
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 360,
        "y": 280,
        "wires": [
            [
                "e740f12a.0dc05"
            ],
            [
                "f87c8d8f.12b57"
            ]
        ]
    },
    {
        "id": "7bfa1941.a93cb8",
        "type": "inject",
        "z": "3674b7d8.02a168",
        "name": "On flow init",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "x": 130,
        "y": 80,
        "wires": [
            [
                "a0e85ecb.fce12"
            ]
        ]
    },
    {
        "id": "bedcc1f5.e56e5",
        "type": "catch",
        "z": "3674b7d8.02a168",
        "name": "Catch available_datapoints.json does not exist",
        "scope": [
            "a0e85ecb.fce12"
        ],
        "uncaught": false,
        "x": 210,
        "y": 140,
        "wires": [
            [
                "dbca598c.21c8a8"
            ]
        ]
    },
    {
        "id": "a0e85ecb.fce12",
        "type": "file in",
        "z": "3674b7d8.02a168",
        "name": "",
        "filename": "/data/available_datapoints.json",
        "format": "utf8",
        "chunk": false,
        "sendError": false,
        "encoding": "none",
        "x": 510,
        "y": 80,
        "wires": [
            [
                "c38da571.9bb178"
            ]
        ]
    },
    {
        "id": "dbca598c.21c8a8",
        "type": "change",
        "z": "3674b7d8.02a168",
        "name": "Use empty object as default value for available_datapoints",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "{}",
                "tot": "json"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 630,
        "y": 140,
        "wires": [
            [
                "40ba839.94a5f7c"
            ]
        ]
    },
    {
        "id": "c38da571.9bb178",
        "type": "json",
        "z": "3674b7d8.02a168",
        "name": "",
        "property": "payload",
        "action": "obj",
        "pretty": false,
        "x": 790,
        "y": 80,
        "wires": [
            [
                "40ba839.94a5f7c"
            ]
        ]
    },
    {
        "id": "40ba839.94a5f7c",
        "type": "change",
        "z": "3674b7d8.02a168",
        "name": "Store available_datapoints in global and mark loaded",
        "rules": [
            {
                "t": "set",
                "p": "available_datapoints",
                "pt": "global",
                "to": "payload",
                "tot": "msg"
            },
            {
                "t": "set",
                "p": "available_datapoints_loaded",
                "pt": "global",
                "to": "true",
                "tot": "bool"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1120,
        "y": 80,
        "wires": [
            []
        ]
    },
    {
        "id": "8531168b.41c518",
        "type": "comment",
        "z": "3674b7d8.02a168",
        "name": "Load the last version of available_datapoints from disk on flow init.",
        "info": "",
        "x": 280,
        "y": 40,
        "wires": []
    },
    {
        "id": "53dbc0f1.2bcc4",
        "type": "file",
        "z": "3674b7d8.02a168",
        "name": "",
        "filename": "/data/available_datapoints.json",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "true",
        "encoding": "none",
        "x": 1150,
        "y": 460,
        "wires": [
            []
        ]
    },
    {
        "id": "48dc7753.985558",
        "type": "comment",
        "z": "3674b7d8.02a168",
        "name": "Update the available_datapoints object and publish if new datapoints have been found.",
        "info": "",
        "x": 340,
        "y": 240,
        "wires": []
    },
    {
        "id": "c7d69be6.186988",
        "type": "json",
        "z": "3674b7d8.02a168",
        "name": "Pretty print json string",
        "property": "payload",
        "action": "str",
        "pretty": true,
        "x": 880,
        "y": 460,
        "wires": [
            [
                "53dbc0f1.2bcc4"
            ]
        ]
    },
    {
        "id": "1c26ecc6.986e53",
        "type": "function",
        "z": "9f1169a9.8e23c8",
        "name": "Throw not implemented error",
        "func": "node.error(\"Logic in flow \\\"Send command\\\" not implemented\")",
        "outputs": 0,
        "noerr": 0,
        "x": 340,
        "y": 40,
        "wires": []
    },
    {
        "id": "43d13ddb.00ffd4",
        "type": "subflow:2f246a38.edf956",
        "z": "927c9b3e.6d8038",
        "name": "",
        "env": [],
        "x": 90,
        "y": 40,
        "wires": []
    },
    {
        "id": "288f6f41.c66be",
        "type": "inject",
        "z": "219558b7.844058",
        "name": "Start request for meters with $(METER_IDS) every $(POLLSECONDS)",
        "topic": "",
        "payload": "$(METER_IDS)",
        "payloadType": "json",
        "repeat": "$(POLL_SECONDS)",
        "crontab": "",
        "once": true,
        "onceDelay": "5",
        "x": 300,
        "y": 360,
        "wires": [
            [
                "5be9e117.4dc01"
            ]
        ]
    },
    {
        "id": "5be9e117.4dc01",
        "type": "split",
        "z": "219558b7.844058",
        "name": "",
        "splt": "\\n",
        "spltType": "str",
        "arraySplt": 1,
        "arraySpltType": "len",
        "stream": false,
        "addname": "",
        "x": 690,
        "y": 360,
        "wires": [
            [
                "4dda9e7e.2a787"
            ]
        ]
    },
    {
        "id": "4dda9e7e.2a787",
        "type": "delay",
        "z": "219558b7.844058",
        "name": "Delay requests to prevent DDOSing the Ambus Net device",
        "pauseType": "rate",
        "timeout": "5",
        "timeoutUnits": "seconds",
        "rate": "$(MAX_POLLS_PER_PERIOD)",
        "nbRateUnits": "$(POLL_SECONDS)",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "x": 1050,
        "y": 360,
        "wires": [
            [
                "5a400299.8cadec"
            ]
        ]
    },
    {
        "id": "5a400299.8cadec",
        "type": "function",
        "z": "219558b7.844058",
        "name": "Build Soap Request in XML",
        "func": "var meter_number = msg.payload\nvar xml_req = `\n<?xml version='1.0' encoding='UTF-8'?>\n<S:Envelope xmlns:S=\"http://schemas.xmlsoap.org/soap/envelope/\">\n    <S:Body>\n        <getMeter xmlns=\"http://tempuri.org/\">\n            <primAddr>\n                ${meter_number}\n            </primAddr>\n        </getMeter>\n    </S:Body>\n</S:Envelope>\n`\nvar headers = {}\nheaders['content-type'] = 'text/xml; charset=utf-8'\nheaders['SOAPAction'] = '\"http://tempuri.org/getMeter\"'\n//headers['Connection'] = 'keep-alive'\n//headers['Accept'] = 'text/xml, multipart/related'\n\nreturn {payload: xml_req,\n        headers: headers}",
        "outputs": 1,
        "noerr": 0,
        "x": 160,
        "y": 620,
        "wires": [
            [
                "d220c78b.a28098"
            ]
        ]
    },
    {
        "id": "d220c78b.a28098",
        "type": "http request",
        "z": "219558b7.844058",
        "name": "Send XML Request to AmbusNet Webservice",
        "method": "POST",
        "ret": "bin",
        "url": "http://141.21.47.85/AmbusNetWS/Service1.asmx",
        "tls": "",
        "x": 490,
        "y": 620,
        "wires": [
            [
                "4ff06620.b07ba8"
            ]
        ]
    },
    {
        "id": "67e81f0b.1a903",
        "type": "inject",
        "z": "219558b7.844058",
        "name": "On flow init",
        "topic": "",
        "payload": "$(METER_IDS)",
        "payloadType": "json",
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "x": 110,
        "y": 80,
        "wires": [
            [
                "19b67db1.82db12"
            ]
        ]
    },
    {
        "id": "90ddded2.bcf4d",
        "type": "function",
        "z": "219558b7.844058",
        "name": "Log requested METER_IDS",
        "func": "let meter_ids = msg.payload\nnode.log(`Using the following meter ids: ${meter_ids}`)",
        "outputs": 0,
        "noerr": 0,
        "x": 580,
        "y": 80,
        "wires": []
    },
    {
        "id": "19b67db1.82db12",
        "type": "json",
        "z": "219558b7.844058",
        "name": "",
        "property": "payload",
        "action": "str",
        "pretty": false,
        "x": 310,
        "y": 80,
        "wires": [
            [
                "90ddded2.bcf4d"
            ]
        ]
    },
    {
        "id": "9f02dbc5.b32d18",
        "type": "inject",
        "z": "219558b7.844058",
        "name": "On flow init",
        "topic": "",
        "payload": "$(AMBUSNETWS_SOAP_URL)",
        "payloadType": "str",
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "x": 110,
        "y": 120,
        "wires": [
            [
                "f02a214d.2d7ea"
            ]
        ]
    },
    {
        "id": "f02a214d.2d7ea",
        "type": "function",
        "z": "219558b7.844058",
        "name": "Log AMBUSNETWS_SOAP_URL",
        "func": "let url = msg.payload\nnode.log(`Using the following Ambus Net SOAP URL: ${url}`)",
        "outputs": 0,
        "noerr": 0,
        "x": 600,
        "y": 120,
        "wires": []
    },
    {
        "id": "ee02774e.d547d8",
        "type": "comment",
        "z": "219558b7.844058",
        "name": "Log the current configuration (via environment variable) to support debugging.",
        "info": "",
        "x": 290,
        "y": 40,
        "wires": []
    },
    {
        "id": "4e466d87.ffe304",
        "type": "inject",
        "z": "219558b7.844058",
        "name": "On flow init",
        "topic": "",
        "payload": "$(POLL_SECONDS)",
        "payloadType": "str",
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "x": 110,
        "y": 160,
        "wires": [
            [
                "3f691175.dc94ee"
            ]
        ]
    },
    {
        "id": "3f691175.dc94ee",
        "type": "function",
        "z": "219558b7.844058",
        "name": "Log POLL_SECONDS",
        "func": "let poll_seconds = msg.payload\nnode.log(`Polling meters every: ${poll_seconds} seconds`)",
        "outputs": 0,
        "noerr": 0,
        "x": 560,
        "y": 160,
        "wires": []
    },
    {
        "id": "a4790bee.caad78",
        "type": "function",
        "z": "219558b7.844058",
        "name": "Log MAX_POLLS_PER_PERIOD",
        "func": "let max_polls = msg.payload\nnode.log(`Polling no more then ${max_polls} per poll period.`)",
        "outputs": 0,
        "noerr": 0,
        "x": 600,
        "y": 200,
        "wires": []
    },
    {
        "id": "cf8dec12.78b48",
        "type": "inject",
        "z": "219558b7.844058",
        "name": "On flow init",
        "topic": "",
        "payload": "$(MAX_POLLS_PER_PERIOD)",
        "payloadType": "str",
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "x": 110,
        "y": 200,
        "wires": [
            [
                "a4790bee.caad78"
            ]
        ]
    },
    {
        "id": "91d393e5.bc106",
        "type": "comment",
        "z": "219558b7.844058",
        "name": "Here the actual request to the Ambus Net meters.",
        "info": "",
        "x": 200,
        "y": 320,
        "wires": []
    },
    {
        "id": "8ea0ad0c.7912f",
        "type": "converter",
        "z": "545ec5f2.a5913c",
        "name": "Convert ISO-8859-1 to UTF-8",
        "from": "ISO-8859-1 ",
        "x": 630,
        "y": 40,
        "wires": [
            [
                "898da714.4a9da8"
            ]
        ]
    },
    {
        "id": "898da714.4a9da8",
        "type": "xml",
        "z": "545ec5f2.a5913c",
        "name": "parse xml anwser to json",
        "property": "payload",
        "attr": "",
        "chr": "",
        "x": 930,
        "y": 40,
        "wires": [
            [
                "2938b61a.a594fa"
            ]
        ]
    },
    {
        "id": "1af4cf17.b34d41",
        "type": "change",
        "z": "545ec5f2.a5913c",
        "name": "raw_message to payload",
        "rules": [
            {
                "t": "set",
                "p": "payload_store",
                "pt": "msg",
                "to": "payload",
                "tot": "msg"
            },
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "payload_store.raw_message",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 330,
        "y": 40,
        "wires": [
            [
                "8ea0ad0c.7912f"
            ]
        ]
    },
    {
        "id": "d4cc8ac5.10cae8",
        "type": "change",
        "z": "545ec5f2.a5913c",
        "name": "Restore output message format",
        "rules": [
            {
                "t": "set",
                "p": "payload_store.parsed_message",
                "pt": "msg",
                "to": "payload",
                "tot": "msg"
            },
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "payload_store",
                "tot": "msg"
            },
            {
                "t": "delete",
                "p": "payload_store",
                "pt": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 690,
        "y": 120,
        "wires": [
            [
                "376a4260.2d545e"
            ]
        ]
    },
    {
        "id": "4ff06620.b07ba8",
        "type": "change",
        "z": "219558b7.844058",
        "name": "Place raw_message in payload.raw_message",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "{'raw_message': msg.payload}",
                "tot": "jsonata"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 880,
        "y": 620,
        "wires": [
            [
                "6aae28b2.fb2688"
            ]
        ]
    },
    {
        "id": "2938b61a.a594fa",
        "type": "function",
        "z": "545ec5f2.a5913c",
        "name": "Add meter number and reduce bloat",
        "func": "/*\nThe JSON object received at this point starts with something like this:\n{\n    \"soap:Envelope\": {\n        \"$\": {\n            \"xmlns:soap\": \"http://schemas.xmlsoap.org/soap/envelope/\",\n            \"xmlns:xsi\": \"http://www.w3.org/2001/XMLSchema-instance\",\n            \"xmlns:xsd\": \"http://www.w3.org/2001/XMLSchema\"\n        },\n        \"soap:Body\": [\n            {\n                \"getMeterResponse\": [\n                    {\n                        \"$\": {\n                            \"xmlns\": \"http://tempuri.org/\"\n                        },\n                        \"getMeterResult\": [\n                            {\n                                \"primAddr\": [\n                                    \"2\"\n                                ],\n                                \"deviceName\": [\n                                    \"FZI  Forschugszentrum Informatik Karlsr\"\n                                ],\n                                \"desc\": [\n                                    \"WMZ Rueck\"\n                                ],\n                                \"type\": [\n                                    \"CALEC ST\"\n                                ],\n                                \"info\": [\n                                    \"AQUAMETRO MESSTECHNIK GmbH\"\n                                ],\n                                \"supplier\": [\n                                    \"AMT\"\n                                ],\n                                \"serial\": [\n                                    \"05331543\"\n                                ],\n                                \"medium\": [\n                                    \"Heat\"\n                                ],\n                                \"instPoint\": [\n                                    \"Cold side\"\n                                ],\n                                \"readout\": [\n                                    \"09.01.20 17:33\"\n                                ],\n                                \"status\": [\n                                    \"ok\"\n                                ],\n                                \"opTime\": [\n                                    {\n                                        \"value\": [\n                                            \"   46753\"\n                                        ],\n                                        \"unit\": [\n                                            \"h\"\n                                        ]\n                                    }\n                                ],\n                                \"errorTime\": [\n                                    {\n                                        \"value\": [\n                                            \"       0\"\n                                        ],\n                                        \"unit\": [\n                                            \"h\"\n                                        ]\n                                    }\n                                ],\n                                \"channel\": [\n                                    {\n                                        \"Channel\": [\n                                            {\n                                                \"P\": [\n                                                    {\n                                                        \"value\": [\n                                                            \"    0.000\"\n                                                        ],\n\n\nThis message has two issues.\n1) It will generate a lot of bloat keys in the flat message, e.g. starting with\n\"soap:Envelope__soap:Body__0__getMeterResponse__0__getMeterResult\"\n2) The meter number is not part of the flattend keys, which makes the values \nof all meters have identical keys.\n\nThe following code fixes both issues.\n*/\nlet payload = msg.payload\nlet meter_result = payload[\"soap:Envelope\"][\"soap:Body\"][0][\"getMeterResponse\"][0][\"getMeterResult\"][0]\nlet meter_number = meter_result[\"primAddr\"]\n\n// Erase the old dict and add the shortend one with the meter number.\nmsg.payload = {}\nmsg.payload[\"meter_\" + meter_number] = meter_result\n\nreturn msg",
        "outputs": 1,
        "noerr": 0,
        "x": 330,
        "y": 120,
        "wires": [
            [
                "d4cc8ac5.10cae8"
            ]
        ]
    },
    {
        "id": "284cd3db.1f53dc",
        "type": "debug",
        "z": "927c9b3e.6d8038",
        "name": "",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "x": 350,
        "y": 460,
        "wires": []
    },
    {
        "id": "dc971a11.e237a8",
        "type": "inject",
        "z": "72d61467.c7c86c",
        "name": "",
        "topic": "",
        "payload": "111",
        "payloadType": "str",
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "x": 170,
        "y": 120,
        "wires": [
            [
                "62898994.d74878"
            ]
        ]
    },
    {
        "id": "432b1aa1.f45864",
        "type": "mqtt in",
        "z": "72d61467.c7c86c",
        "name": "",
        "topic": "$(MQTT_TOPIC_DATAPOINT_MAP)",
        "qos": "1",
        "datatype": "json",
        "broker": "f0d21eb0.93967",
        "x": 490,
        "y": 160,
        "wires": [
            [
                "d8495355.cf2e2"
            ]
        ]
    },
    {
        "id": "62898994.d74878",
        "type": "mqtt out",
        "z": "72d61467.c7c86c",
        "name": "",
        "topic": "$(MQTT_TOPIC_DATAPOINT_MAP)",
        "qos": "2",
        "retain": "true",
        "broker": "f0d21eb0.93967",
        "x": 600,
        "y": 100,
        "wires": []
    },
    {
        "id": "d8495355.cf2e2",
        "type": "debug",
        "z": "72d61467.c7c86c",
        "name": "",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "x": 790,
        "y": 160,
        "wires": []
    },
    {
        "id": "bc388144.0d621",
        "type": "function",
        "z": "a96a98ee.ee4868",
        "name": "Validate received datapoint_map",
        "func": "/*\nCheck that the datapoint map is structured as follows:\n{\"sensor\": {}, \"actuator\": {}}\nThe empty objects above may contain the actuall mappings or not in reality, but\nmust exist. Else the filter nodes in the Main flow will fail and throw erros.\n*/\n\n// Based on an anwser here: \n// https://stackoverflow.com/questions/8511281/check-if-a-value-is-an-object-in-javascript\nisObject = function(a) {\n    return Object.prototype.toString.call(a) === \"[object Object]\"\n}\n\nlet reject_datapoint_map_reason = \"\"\n\nlet datapoint_map = msg.payload\n\nif ( ! isObject(datapoint_map) ) {\n    reject_datapoint_map_reason = \"Datapoint_map is no object.\"\n} else if ( ! (\"sensor\" in datapoint_map) ) {\n    reject_datapoint_map_reason = \"No sensor key in datapoint_map.\"\n} else if ( ! (\"actuator\" in datapoint_map) ) {\n    reject_datapoint_map_reason = \"No actuator key in datapoint_map.\"\n} else if ( ! isObject(datapoint_map[\"sensor\"]) ) {\n    reject_datapoint_map_reason = \"Sensor key in datapoint_map contains no object.\"\n} else if ( ! isObject(datapoint_map[\"actuator\"]) ) {\n    reject_datapoint_map_reason = \"Actuator key in datapoint_map contains no object.\"\n}\n\nif ( reject_datapoint_map_reason !== \"\" ){\n    node.error(\"Rejecting datapoint_map with reason: \" + reject_datapoint_map_reason)\n} else {\n    node.warn(\"got datapoint map\", msg)\n    return msg\n}",
        "outputs": 1,
        "noerr": 0,
        "x": 550,
        "y": 80,
        "wires": [
            [
                "b667759e.2c1018"
            ]
        ]
    }
]