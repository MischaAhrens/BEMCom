[{"id":"927c9b3e.6d8038","type":"tab","label":"Flow 2","disabled":false,"info":""},{"id":"a94a6f85.3fe41","type":"tab","label":"Flow 1","disabled":false,"info":""},{"id":"a1058abf.d7f1d8","type":"subflow","name":"Subflow 2","info":"","category":"","in":[{"x":40,"y":120,"wires":[{"id":"52fd0e81.fa125"}]}],"out":[{"x":580,"y":120,"wires":[{"id":"2c9b902f.a4563","port":0}]}],"env":[{"name":"REQUEST_URL","type":"str","value":"https://example.com"}],"color":"#DDAA99"},{"id":"630ce853.304e48","type":"subflow","name":"Receive raw_msg from X","info":"All logic necessary to receive data from device or data source.\n\n# Returns\nShould return the received message as raw message in the format:\n```\nmsg = {\n 'payload': {\n    'raw_message': <the raw data>\n }\n}```","category":"","in":[],"out":[{"x":640,"y":140,"wires":[]}],"env":[],"color":"#a3b9d0","icon":"node-red/arrow-in.svg"},{"id":"77793d85.aff8e4","type":"subflow","name":"store raw_msg in DB","info":"","category":"","in":[{"x":40,"y":140,"wires":[{"id":"14c20904.ccb857"}]}],"out":[],"env":[],"color":"#C7E9C0","icon":"node-red/db.svg"},{"id":"2f246a38.edf956","type":"subflow","name":"Log handler","info":"A central log handler that exposes all log messages of Node-REDs internal logger as messages, and thus allows forwarding the logs to a central monitoring instance.  \nThe log handler uses a TCP socket to connect Node-REDs internal logger with the flow.\n\n# Usage\nDeploy one (and only one) instance of the node in a Node-RED instance. If you deploy more than one node the following error will occur:\n```\n\"unable to listen on port 1337, error: Error: listen EADDRINUSE: address already in use :::1338\"\n```\n\nAll log messages will be caught automatically, this includes the warn and error messages displayed in Node-REDs debug message log but also the internal info messages not shown there. \n\nTo explicitly log in function nodes use the `node` attribute as explained [here](https://nodered.org/docs/user-guide/writing-functions#logging-events), i.e. use: \n\n```\nnode.log(..)\nnode.warn(..)\nnode.error(..)\nnode.debug(..)\nnode.trace(..)\n```\n\n# Log levels\n\n... are converted to python standard, that is:\n\n* 10 (DEBUG) Something happened which is only relevant for developers of the application.\n* 20 (INFO) Something happened.\n* 30 (WARN) Something happened, which is not a problem a the moment but may become one in future. No data is lost.\n* 40 (ERROR) An error occurred, the processing of one or more messages failed. Some data is lost and/or has not reached the end of the flow. Node-RED and the flows still work.\n* 50 (FATAL) A flow or Node-RED crashed and does not operation as intended. You should not expect that FATAL logs are forwarded as the flow may already be halted.\n\n# Known bugs\nAfter a redeploy (not the first startup) of the application it may take 5-10 seconds until the connection is reestablished. Log messages may be lost within that time.\n\n# Preliminaries\n\nIn order to make this flow work one needs to append the following code into `settings.js` in the `logging` section:\n\n```\n// Custom log handler that forwards log messages via tcp socket.\n        logforwarder: {\n            // Node red logger configuration see https://nodered.org/docs/user-guide/runtime/logging\n            level: 'info',\n            metrics: false,\n            audit: false,\n            handler: function(conf) {\n                var net = require('net')\n                var logPort = 1337\n                var logHost = 'localhost'\n                var message_cache = []\n                var client_connected = false\n                var client = new net.Socket()\n\n                // Send all cached messages once the connection is established.\n                client.on('connect', function() {\n                    console.log(\"LogForwarder connected\")\n                    client_connected = true\n                    while(message_cache.length) {\n                        client.write(JSON.stringify(message_cache.shift())+\"\\n\")\n                    }\n\n                })\n\n                // Handle connection errors, flag connection inactive and issue reconnect.\n                client.on('error', function() {\n                    // Ignore errors that occurred while the socket was not connected.\n                    if (client_connected === true) {\n                        console.log(\"LogForwarder connection error, Reconnecting.\")\n                        client.destroy()\n                        client = new net.Socket()\n                        client_connected = false\n                        client.setTimeout(2000, function() {\n                            client.connect(logPort, logHost)\n                        })\n                    }\n                })\n\n                // Return the function that will do the actual logging to the logging system.\n                return function(msg) {\n                    if (client_connected === true) {\n                        try {\n                            client.write(JSON.stringify(msg)+\"\\n\")\n                        } catch(err) {\n                            // Trigger caching and reconnecting on error.\n                            client.destroy()\n                            client = new net.Socket()\n                            client_connected = false\n                        }\n                    } \n                    // Cache messages if connection is lost.\n                    if (client_connected === false) {\n                        message_cache.push(msg)\n                        // Only trigger reconnect if a message is waiting to be sent.\n                        if (client.connecting === false) {\n                            client.connect(logPort, logHost)\n                        }\n                    }\n                }\n            }\n        }\n```","category":"","in":[],"out":[],"env":[],"color":"#7bb27f","icon":"node-red/envelope.svg","status":{"x":800,"y":280,"wires":[{"id":"d09fe5cf.357788","port":0}]}},{"id":"bc89d4f9.14c848","type":"tls-config","z":"","name":"","cert":"","key":"","ca":"","certname":"","keyname":"","caname":"","servername":"","verifyservercert":true},{"id":"879bee.da78c41","type":"mqtt-broker","z":"2f246a38.edf956","name":"environment variable broker","broker":"$(MQTT_BROKER_HOST)","port":"$(MQTT_BROKER_PORT)","clientid":"","usetls":false,"compatmode":false,"keepalive":"60","cleansession":true,"birthTopic":"","birthQos":"0","birthPayload":"","closeTopic":"","closeQos":"0","closePayload":"","willTopic":"","willQos":"0","willPayload":""},{"id":"f0d21eb0.93967","type":"mqtt-broker","z":"","name":"environment variable broker","broker":"$(MQTT_BROKER_HOST)","port":"$(MQTT_BROKER_PORT)","clientid":"","usetls":false,"compatmode":false,"keepalive":"60","cleansession":true,"birthTopic":"","birthQos":"0","birthPayload":"","closeTopic":"","closeQos":"0","closePayload":"","willTopic":"","willQos":"0","willPayload":""},{"id":"2c9b902f.a4563","type":"http request","z":"a1058abf.d7f1d8","name":"","method":"GET","ret":"txt","paytoqs":false,"url":"","tls":"bc89d4f9.14c848","persist":false,"proxy":"","authType":"","x":430,"y":120,"wires":[[]]},{"id":"52fd0e81.fa125","type":"change","z":"a1058abf.d7f1d8","name":"","rules":[{"t":"set","p":"url2","pt":"msg","to":"REQUEST_URL","tot":"env"}],"action":"","property":"","from":"","to":"","reg":false,"x":190,"y":120,"wires":[["2c9b902f.a4563"]]},{"id":"f4ae9d15.9bca9","type":"catch","z":"a1058abf.d7f1d8","name":"","scope":null,"uncaught":false,"x":80,"y":40,"wires":[[]]},{"id":"b56d5210.4ed39","type":"subflow:630ce853.304e48","z":"927c9b3e.6d8038","name":"","env":[],"x":170,"y":140,"wires":[["1980e6e1.5dc979"]]},{"id":"1980e6e1.5dc979","type":"change","z":"927c9b3e.6d8038","name":"Add receival timestamp","rules":[{"t":"set","p":"timestamp","pt":"msg","to":"","tot":"date"}],"action":"","property":"","from":"","to":"","reg":false,"x":450,"y":140,"wires":[["e725b9ac.340508"]]},{"id":"e725b9ac.340508","type":"subflow:77793d85.aff8e4","z":"927c9b3e.6d8038","name":"","env":[],"x":740,"y":140,"wires":[]},{"id":"f6adda79.b02428","type":"function","z":"630ce853.304e48","name":"Throw not implemented error","func":"node.error(\"Receive raw msg from DB not implemented.\", msg)","outputs":0,"noerr":0,"x":400,"y":140,"wires":[]},{"id":"c618c384.0a03e","type":"inject","z":"630ce853.304e48","name":"","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":120,"y":140,"wires":[["f6adda79.b02428","5f8c4ff8.cb04f"]]},{"id":"70a8cfef.b75c5","type":"subflow:2f246a38.edf956","z":"a1058abf.d7f1d8","name":"","x":290,"y":40,"wires":[]},{"id":"14c20904.ccb857","type":"function","z":"77793d85.aff8e4","name":"Throw not implemented error","func":"throw \"Not implemented.\"","outputs":0,"noerr":0,"x":240,"y":140,"wires":[]},{"id":"a680cff8.31c22","type":"inject","z":"927c9b3e.6d8038","name":"","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":true,"onceDelay":0.1,"x":230,"y":380,"wires":[["56ca7ced.ae3e74"]]},{"id":"56ca7ced.ae3e74","type":"function","z":"927c9b3e.6d8038","name":"","func":"node.log('TEest 112233')\nnode.warn('Some warning')","outputs":1,"noerr":0,"x":650,"y":380,"wires":[[]]},{"id":"5f8c4ff8.cb04f","type":"debug","z":"630ce853.304e48","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","x":320,"y":200,"wires":[]},{"id":"ac872115.7ebd2","type":"tcp in","z":"2f246a38.edf956","name":"","server":"server","host":"","port":"1337","datamode":"stream","datatype":"utf8","newline":"\\n","topic":"","base64":false,"x":100,"y":80,"wires":[["7cba1842.0813a8"]]},{"id":"d4772456.48c0d8","type":"comment","z":"2f246a38.edf956","name":"Display the combined status of the tcp connection with the Node-RED logger and mqtt connection as subflow status.","info":"","x":430,"y":240,"wires":[]},{"id":"a7489345.cc4ee","type":"function","z":"2f246a38.edf956","name":"Format log msg","func":"/*\nThe incomming object looks like:\n\ntopic: \"\"\npayload: \n    level: 40\n    id: \"21b82c2e.44d1e4\"\n    type: \"function\"\n    msg: \"TEest 112233\"\n    _alias: \"cd54c61d.3064d8\"\n    z: \"81cb38e5.a724b8\"\n    timestamp: 1571843907448\nip: \"::ffff:127.0.0.1\"\nport: 54404\n_session:\n    type: \"tcp\"\n    id: \"b4c68458.f1e368\"\n_msgid: \"ef84fdce.533b1\"\n\nThe outgoing msg should look like:\npayload: \n    timestamp: 1571843907448\n    msg: \"TEest 112233\"\n    emitter: \"cd54c61d.3064d8\"\n    level: 20\n*/ \n\n// The node id of the emitting node is stored in _alias if the node is within a\n// subflow. Else it's the id field\nlet emitter\nif ('_alias' in msg.payload) {\n    emitter = msg.payload._alias\n} else {\n    emitter = msg.payload.id\n}\n\n// Parse the log levels to Python convention\nlet level\nswitch (msg.payload.level) {\n    case 10:\n        level = 50\n        break\n    case 20:\n        level = 40\n        break\n    case 30:\n        level = 30\n        break\n    case 40:\n        level = 20\n        break\n    case 50:\n        level = 10\n        break\n    default:\n        level = null\n}\n\npayload = {\n    \"timestamp\": msg.payload.timestamp,\n    \"msg\": msg.payload.msg,\n    \"emitter\": emitter,\n    \"level\": level\n}\n\nreturn {\"payload\": payload}","outputs":1,"noerr":0,"x":560,"y":80,"wires":[["f18f0326.62d8b"]]},{"id":"7cba1842.0813a8","type":"json","z":"2f246a38.edf956","name":"String to JSON objecet","property":"payload","action":"obj","pretty":false,"x":320,"y":80,"wires":[["a7489345.cc4ee"]]},{"id":"8c4b1179.2783d","type":"comment","z":"2f246a38.edf956","name":"The pipe line for the log msgs. Append other endpoints as required.","info":"","x":280,"y":40,"wires":[]},{"id":"21851378.d4789c","type":"comment","z":"927c9b3e.6d8038","name":"Heartbeat","info":"","x":320,"y":60,"wires":[]},{"id":"f18f0326.62d8b","type":"mqtt out","z":"2f246a38.edf956","name":"","topic":"$(MQTT_TOPIC_LOGS)","qos":"2","retain":"false","broker":"879bee.da78c41","x":830,"y":80,"wires":[]},{"id":"2b6a2982.2201b6","type":"mqtt in","z":"927c9b3e.6d8038","name":"","topic":"$(MQTT_TOPIC_LOGS)","qos":"2","datatype":"auto","broker":"f0d21eb0.93967","x":260,"y":540,"wires":[[]]},{"id":"79a2936a.bfe19c","type":"tcp in","z":"a94a6f85.3fe41","name":"","server":"server","host":"","port":"1337","datamode":"stream","datatype":"utf8","newline":"\\n","topic":"","base64":false,"x":120,"y":120,"wires":[["58fce4ad.c61c2c"]]},{"id":"4797acb8.3b3b04","type":"status","z":"a94a6f85.3fe41","name":"","scope":["79a2936a.bfe19c","73402744.778918"],"x":120,"y":340,"wires":[["838bdfa7.2ee6e"]]},{"id":"e7ea8bb3.d76c38","type":"comment","z":"a94a6f85.3fe41","name":"Display the status of the (tcp) connection with the Node-RED logger as subflow status","info":"","x":360,"y":240,"wires":[]},{"id":"e999e493.df8d38","type":"function","z":"a94a6f85.3fe41","name":"Format log msg","func":"/*\nThe incomming object looks like:\n\ntopic: \"\"\npayload: \n    level: 40\n    id: \"21b82c2e.44d1e4\"\n    type: \"function\"\n    msg: \"TEest 112233\"\n    _alias: \"cd54c61d.3064d8\"\n    z: \"81cb38e5.a724b8\"\n    timestamp: 1571843907448\nip: \"::ffff:127.0.0.1\"\nport: 54404\n_session:\n    type: \"tcp\"\n    id: \"b4c68458.f1e368\"\n_msgid: \"ef84fdce.533b1\"\n\nThe outgoing msg should look like:\npayload: \n    timestamp: 1571843907448\n    msg: \"TEest 112233\"\n    emitter: \"cd54c61d.3064d8\"\n    level: 20\n*/ \n\n// The node id of the emitting node is stored in _alias if the node is within a\n// subflow. Else it's the id field\nlet emitter\nif ('_alias' in msg.payload) {\n    emitter = msg.payload._alias\n} else {\n    emitter = msg.payload.id\n}\n\n// Parse the log levels to Python convention\nlet level\nswitch (msg.payload.level) {\n    case 10:\n        level = 50\n        break\n    case 20:\n        level = 40\n        break\n    case 30:\n        level = 30\n        break\n    case 40:\n        level = 20\n        break\n    case 50:\n        level = 10\n        break\n    default:\n        level = null\n}\n\npayload = {\n    \"timestamp\": msg.payload.timestamp,\n    \"msg\": msg.payload.msg,\n    \"emitter\": emitter,\n    \"level\": level\n}\n\nreturn {\"payload\": payload}","outputs":1,"noerr":0,"x":580,"y":120,"wires":[["73402744.778918"]]},{"id":"58fce4ad.c61c2c","type":"json","z":"a94a6f85.3fe41","name":"String to JSON objecet","property":"payload","action":"obj","pretty":false,"x":340,"y":120,"wires":[["e999e493.df8d38"]]},{"id":"71383d81.4991f4","type":"comment","z":"a94a6f85.3fe41","name":"The pipe line for the log msgs. Append other endpoints as required.","info":"","x":300,"y":80,"wires":[]},{"id":"73402744.778918","type":"mqtt out","z":"a94a6f85.3fe41","name":"","topic":"$(MQTT_TOPIC_LOGS)","qos":"2","retain":"false","broker":"f0d21eb0.93967","x":850,"y":120,"wires":[]},{"id":"838bdfa7.2ee6e","type":"function","z":"a94a6f85.3fe41","name":"Compute subflow status","func":"/* This node will receive status messages from \"tcp in\" node and \"mqtt out\".\n\nThe \"tcp in\" status looks like this:\nstatus:\n    text: \"1 connection\"\n    event: \"connect\"\n    ip: \"::ffff:127.0.0.1\"\n    port: 57886\n_session:\n    type: \"tcp\"\n    id: \"4a30194f.2d0008\"\nsource:\n    id: \"51c67f81.6eaad\"\n    type: \"tcp in\"\n_msgid: \"bb2b70c5.abf9f\"\n\nThe \"mqtt out\" status like this:\nstatus:\n    fill: \"yellow\"\n    shape: \"ring\"\n    text: \"node-red:common.status.connecting\"\nsource:\n    id: \"9a6c9ede.e185c\"\n    type: \"mqtt out\"\n_msgid: \"45a3aa0f.960234\"\n\nThe following code will compute the following status:\n* green (connected): if both ends are connected.\n* yellow ring (connecting): if any of both ends are still connecting.\n* grey ring (unknown): for undefined states, especially if more than\n  one endpoint is connected to \"tcp in\"\n* red (disconnected): If one of both nodes is not connected.\n*/\n\n// Store the last status for each of the two nodes, as only one is received\n// at a time but both are required to compute the status.\nif (msg.status.source.type === \"mqtt out\") {\n    context.set('mqtt_status_text', msg.status.text)\n}\nif (msg.status.source.type === \"tcp in\") {\n    context.set('tcp_status_text', msg.status.text)\n}\n\n// Compute the status.\nlet status\nlet mqtt_status_text = context.get(\"mqtt_status_text\") || \"node-red:common.status.disconnected\"\nlet tcp_status_text = context.get(\"tcp_status_text\") || \"0 connection\"\n\nif (mqtt_status_text === \"node-red:common.status.connected\" && \n        tcp_status_text === \"1 connection\") {\n    status = {\n        \"fill\": \"green\",\n        \"shape\": \"dot\",\n        \"text\": \"node-red:common.status.connected\"\n    }\n    return {\"status\": status}\n}\n\nif (mqtt_status_text === \"node-red:common.status.disconnected\" || \n        tcp_status_text === \"0 connection\") {\n    status = {\n        \"fill\": \"red\",\n        \"shape\": \"ring\",\n        \"text\": \"node-red:common.status.disconnected\",\n        \"tcp status\": tcp_status_text\n    }\n    return {\"status\": status}\n}\n\n// TCP in has no connecting phase. Hence only connecting status\n// if already connected to tcp in.\nif (mqtt_status_text === \"node-red:common.status.connecting\" && \n        tcp_status_text === \"1 connection\") {\n    status = {\n        \"fill\": \"yellow\",\n        \"shape\": \"ring\",\n        \"text\": \"node-red:common.status.connecting\"\n    }\n    return {\"status\": status}\n}\n\n// For every other state, which should \nstatus = {\n    \"fill\": \"grey\",\n    \"shape\": \"ring\",\n    \"text\": \"unknown\"\n}\n\nreturn {\"status\": status}","outputs":1,"noerr":0,"x":430,"y":340,"wires":[[]]},{"id":"269a9da2.6ce062","type":"status","z":"2f246a38.edf956","name":"","scope":["ac872115.7ebd2","f18f0326.62d8b"],"x":100,"y":280,"wires":[["d09fe5cf.357788"]]},{"id":"d09fe5cf.357788","type":"function","z":"2f246a38.edf956","name":"Compute subflow status","func":"/* This node will receive status messages from \"tcp in\" node and \"mqtt out\".\n\nThe \"tcp in\" status looks like this:\nstatus:\n    text: \"1 connection\"\n    event: \"connect\"\n    ip: \"::ffff:127.0.0.1\"\n    port: 57886\n_session:\n    type: \"tcp\"\n    id: \"4a30194f.2d0008\"\nsource:\n    id: \"51c67f81.6eaad\"\n    type: \"tcp in\"\n_msgid: \"bb2b70c5.abf9f\"\n\nThe \"mqtt out\" status like this:\nstatus:\n    fill: \"yellow\"\n    shape: \"ring\"\n    text: \"node-red:common.status.connecting\"\nsource:\n    id: \"9a6c9ede.e185c\"\n    type: \"mqtt out\"\n_msgid: \"45a3aa0f.960234\"\n\nThe following code will compute the following status:\n* green (connected): if both ends are connected.\n* yellow ring (connecting): if any of both ends are still connecting.\n* grey ring (unknown): for undefined states, especially if more than\n  one endpoint is connected to \"tcp in\"\n* red (disconnected): If one of both nodes is not connected.\n*/\n\n// Store the last status for each of the two nodes, as only one is received\n// at a time but both are required to compute the status.\nif (msg.status.source.type === \"mqtt out\") {\n    context.set('mqtt_status_text', msg.status.text)\n}\nif (msg.status.source.type === \"tcp in\") {\n    context.set('tcp_status_text', msg.status.text)\n}\n\n// Compute the status.\nlet status\nlet mqtt_status_text = context.get(\"mqtt_status_text\") || \"node-red:common.status.disconnected\"\nlet tcp_status_text = context.get(\"tcp_status_text\") || \"0 connection\"\n\nif (mqtt_status_text === \"node-red:common.status.connected\" && \n        tcp_status_text === \"1 connection\") {\n    status = {\n        \"fill\": \"green\",\n        \"shape\": \"dot\",\n        \"text\": \"node-red:common.status.connected\"\n    }\n    return {\"status\": status}\n}\n\nif (mqtt_status_text === \"node-red:common.status.disconnected\" || \n        tcp_status_text === \"0 connection\") {\n    status = {\n        \"fill\": \"red\",\n        \"shape\": \"ring\",\n        \"text\": \"node-red:common.status.disconnected\",\n        \"tcp status\": tcp_status_text\n    }\n    return {\"status\": status}\n}\n\n// TCP in has no connecting phase. Hence only connecting status\n// if already connected to tcp in.\nif (mqtt_status_text === \"node-red:common.status.connecting\" && \n        tcp_status_text === \"1 connection\") {\n    status = {\n        \"fill\": \"yellow\",\n        \"shape\": \"ring\",\n        \"text\": \"node-red:common.status.connecting\"\n    }\n    return {\"status\": status}\n}\n\n// For every other state, which should \nstatus = {\n    \"fill\": \"grey\",\n    \"shape\": \"ring\",\n    \"text\": \"unknown\"\n}\n\nreturn {\"status\": status}","outputs":1,"noerr":0,"x":470,"y":280,"wires":[[]]},{"id":"f4d433ca.d3cce","type":"subflow:2f246a38.edf956","z":"927c9b3e.6d8038","name":"","x":130,"y":60,"wires":[]}]